# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _multiresolutionimageinterface
else:
    import _multiresolutionimageinterface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _multiresolutionimageinterface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _multiresolutionimageinterface.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _multiresolutionimageinterface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _multiresolutionimageinterface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _multiresolutionimageinterface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _multiresolutionimageinterface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _multiresolutionimageinterface:
_multiresolutionimageinterface.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _multiresolutionimageinterface.SHARED_PTR_DISOWN
class vector_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_int___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _multiresolutionimageinterface.vector_int___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_int___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _multiresolutionimageinterface.vector_int_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_int_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_int_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int_size(self)

    def swap(self, v: "vector_int") -> "void":
        return _multiresolutionimageinterface.vector_int_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_int_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_int_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_int_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _multiresolutionimageinterface.vector_int_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_int_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _multiresolutionimageinterface.vector_int_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_int_swiginit(self, _multiresolutionimageinterface.new_vector_int(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_int_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _multiresolutionimageinterface.vector_int_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_int_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_int_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_int_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _multiresolutionimageinterface.vector_int_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_int

# Register vector_int in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_int_swigregister(vector_int)

class vector_uint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_uint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _multiresolutionimageinterface.vector_uint___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_uint___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _multiresolutionimageinterface.vector_uint_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_uint_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_uint_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint_size(self)

    def swap(self, v: "vector_uint") -> "void":
        return _multiresolutionimageinterface.vector_uint_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_uint_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _multiresolutionimageinterface.vector_uint_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_uint_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _multiresolutionimageinterface.vector_uint_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_uint_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _multiresolutionimageinterface.vector_uint_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_uint_swiginit(self, _multiresolutionimageinterface.new_vector_uint(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_uint_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _multiresolutionimageinterface.vector_uint_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_uint_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_uint_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_uint_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _multiresolutionimageinterface.vector_uint_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_uint

# Register vector_uint in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_uint_swigregister(vector_uint)

class vector_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_float_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_float___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_float___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _multiresolutionimageinterface.vector_float___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_float___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _multiresolutionimageinterface.vector_float_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_float_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_float_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float_size(self)

    def swap(self, v: "vector_float") -> "void":
        return _multiresolutionimageinterface.vector_float_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _multiresolutionimageinterface.vector_float_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _multiresolutionimageinterface.vector_float_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_float_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _multiresolutionimageinterface.vector_float_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_float_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _multiresolutionimageinterface.vector_float_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_float_swiginit(self, _multiresolutionimageinterface.new_vector_float(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_float_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _multiresolutionimageinterface.vector_float_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_float_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_float_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_float_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _multiresolutionimageinterface.vector_float_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_float

# Register vector_float in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_float_swigregister(vector_float)

class vector_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_double___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _multiresolutionimageinterface.vector_double___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_double___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _multiresolutionimageinterface.vector_double_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_double_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_double_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double_size(self)

    def swap(self, v: "vector_double") -> "void":
        return _multiresolutionimageinterface.vector_double_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _multiresolutionimageinterface.vector_double_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _multiresolutionimageinterface.vector_double_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_double_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _multiresolutionimageinterface.vector_double_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_double_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _multiresolutionimageinterface.vector_double_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_double_swiginit(self, _multiresolutionimageinterface.new_vector_double(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_double_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _multiresolutionimageinterface.vector_double_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_double_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_double_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_double_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _multiresolutionimageinterface.vector_double_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_double

# Register vector_double in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_double_swigregister(vector_double)

class vector_annotation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_annotation_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< Annotation > >::difference_type", j: "std::vector< std::shared_ptr< Annotation > >::difference_type") -> "std::vector< std::shared_ptr< Annotation >,std::allocator< std::shared_ptr< Annotation > > > *":
        return _multiresolutionimageinterface.vector_annotation___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< Annotation > >::difference_type", j: "std::vector< std::shared_ptr< Annotation > >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_annotation___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type":
        return _multiresolutionimageinterface.vector_annotation_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< Annotation > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_size(self)

    def swap(self, v: "vector_annotation") -> "void":
        return _multiresolutionimageinterface.vector_annotation_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< Annotation > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< Annotation > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< Annotation > >::allocator_type":
        return _multiresolutionimageinterface.vector_annotation_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< Annotation > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_annotation_swiginit(self, _multiresolutionimageinterface.new_vector_annotation(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< Annotation > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_front(self)

    def back(self) -> "std::vector< std::shared_ptr< Annotation > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< Annotation > >::size_type", x: "std::vector< std::shared_ptr< Annotation > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< Annotation > >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_annotation_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< Annotation > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_annotation

# Register vector_annotation in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_annotation_swigregister(vector_annotation)

class vector_annotation_group(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_annotation_group_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< AnnotationGroup > >::difference_type", j: "std::vector< std::shared_ptr< AnnotationGroup > >::difference_type") -> "std::vector< std::shared_ptr< AnnotationGroup >,std::allocator< std::shared_ptr< AnnotationGroup > > > *":
        return _multiresolutionimageinterface.vector_annotation_group___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< AnnotationGroup > >::difference_type", j: "std::vector< std::shared_ptr< AnnotationGroup > >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type":
        return _multiresolutionimageinterface.vector_annotation_group_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_annotation_group_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group_size(self)

    def swap(self, v: "vector_annotation_group") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_group_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::reverse_iterator":
        return _multiresolutionimageinterface.vector_annotation_group_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::allocator_type":
        return _multiresolutionimageinterface.vector_annotation_group_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< AnnotationGroup > >::iterator":
        return _multiresolutionimageinterface.vector_annotation_group_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_annotation_group_swiginit(self, _multiresolutionimageinterface.new_vector_annotation_group(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group_front(self)

    def back(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &":
        return _multiresolutionimageinterface.vector_annotation_group_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< AnnotationGroup > >::size_type", x: "std::vector< std::shared_ptr< AnnotationGroup > >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< AnnotationGroup > >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_annotation_group_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< AnnotationGroup > >::size_type":
        return _multiresolutionimageinterface.vector_annotation_group_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_annotation_group

# Register vector_annotation_group in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_annotation_group_swigregister(vector_annotation_group)

class vector_unsigned_long_long(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_unsigned_long_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        return _multiresolutionimageinterface.vector_unsigned_long_long___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_unsigned_long_long_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_size(self)

    def swap(self, v: "vector_unsigned_long_long") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        return _multiresolutionimageinterface.vector_unsigned_long_long_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_unsigned_long_long_swiginit(self, _multiresolutionimageinterface.new_vector_unsigned_long_long(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        return _multiresolutionimageinterface.vector_unsigned_long_long_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_unsigned_long_long_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        return _multiresolutionimageinterface.vector_unsigned_long_long_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_unsigned_long_long

# Register vector_unsigned_long_long in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_unsigned_long_long_swigregister(vector_unsigned_long_long)

class vector_long_long(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_long_long_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long___len__(self)

    def __getslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "std::vector< long long,std::allocator< long long > > *":
        return _multiresolutionimageinterface.vector_long_long___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_long_long___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        return _multiresolutionimageinterface.vector_long_long_pop(self)

    def append(self, x: "std::vector< long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_long_long_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_long_long_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long_size(self)

    def swap(self, v: "vector_long_long") -> "void":
        return _multiresolutionimageinterface.vector_long_long_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_long_long_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        return _multiresolutionimageinterface.vector_long_long_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_long_long_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        return _multiresolutionimageinterface.vector_long_long_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_long_long_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        return _multiresolutionimageinterface.vector_long_long_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_long_long_swiginit(self, _multiresolutionimageinterface.new_vector_long_long(*args))

    def push_back(self, x: "std::vector< long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_long_long_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        return _multiresolutionimageinterface.vector_long_long_back(self)

    def assign(self, n: "std::vector< long long >::size_type", x: "std::vector< long long >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_long_long_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_long_long_insert(self, *args)

    def reserve(self, n: "std::vector< long long >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_long_long_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        return _multiresolutionimageinterface.vector_long_long_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_long_long

# Register vector_long_long in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_long_long_swigregister(vector_long_long)

class vector_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _multiresolutionimageinterface.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _multiresolutionimageinterface.vector_string_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_string_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string_size(self)

    def swap(self, v: "vector_string") -> "void":
        return _multiresolutionimageinterface.vector_string_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _multiresolutionimageinterface.vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _multiresolutionimageinterface.vector_string_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_string_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _multiresolutionimageinterface.vector_string_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _multiresolutionimageinterface.vector_string_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_string_swiginit(self, _multiresolutionimageinterface.new_vector_string(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_string_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _multiresolutionimageinterface.vector_string_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _multiresolutionimageinterface.vector_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_string_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _multiresolutionimageinterface.vector_string_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_string

# Register vector_string in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_string_swigregister(vector_string)

class vector_point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.vector_point_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.vector_point___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.vector_point___bool__(self)

    def __len__(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point___len__(self)

    def __getslice__(self, i: "std::vector< Point >::difference_type", j: "std::vector< Point >::difference_type") -> "std::vector< Point,std::allocator< Point > > *":
        return _multiresolutionimageinterface.vector_point___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Point >::difference_type", j: "std::vector< Point >::difference_type") -> "void":
        return _multiresolutionimageinterface.vector_point___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point___setitem__(self, *args)

    def pop(self) -> "std::vector< Point >::value_type":
        return _multiresolutionimageinterface.vector_point_pop(self)

    def append(self, x: "Point") -> "void":
        return _multiresolutionimageinterface.vector_point_append(self, x)

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.vector_point_empty(self)

    def size(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point_size(self)

    def swap(self, v: "vector_point") -> "void":
        return _multiresolutionimageinterface.vector_point_swap(self, v)

    def begin(self) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_begin(self)

    def end(self) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_end(self)

    def rbegin(self) -> "std::vector< Point >::reverse_iterator":
        return _multiresolutionimageinterface.vector_point_rbegin(self)

    def rend(self) -> "std::vector< Point >::reverse_iterator":
        return _multiresolutionimageinterface.vector_point_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.vector_point_clear(self)

    def get_allocator(self) -> "std::vector< Point >::allocator_type":
        return _multiresolutionimageinterface.vector_point_get_allocator(self)

    def pop_back(self) -> "void":
        return _multiresolutionimageinterface.vector_point_pop_back(self)

    def erase(self, *args) -> "std::vector< Point >::iterator":
        return _multiresolutionimageinterface.vector_point_erase(self, *args)

    def __init__(self, *args):
        _multiresolutionimageinterface.vector_point_swiginit(self, _multiresolutionimageinterface.new_vector_point(*args))

    def push_back(self, x: "Point") -> "void":
        return _multiresolutionimageinterface.vector_point_push_back(self, x)

    def front(self) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point_front(self)

    def back(self) -> "std::vector< Point >::value_type const &":
        return _multiresolutionimageinterface.vector_point_back(self)

    def assign(self, n: "std::vector< Point >::size_type", x: "Point") -> "void":
        return _multiresolutionimageinterface.vector_point_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point_resize(self, *args)

    def insert(self, *args) -> "void":
        return _multiresolutionimageinterface.vector_point_insert(self, *args)

    def reserve(self, n: "std::vector< Point >::size_type") -> "void":
        return _multiresolutionimageinterface.vector_point_reserve(self, n)

    def capacity(self) -> "std::vector< Point >::size_type":
        return _multiresolutionimageinterface.vector_point_capacity(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_vector_point

# Register vector_point in _multiresolutionimageinterface:
_multiresolutionimageinterface.vector_point_swigregister(vector_point)

class map_int_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string___bool__(self)

    def __len__(self) -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< int,std::string >::key_type const &") -> "std::map< int,std::string >::mapped_type const &":
        return _multiresolutionimageinterface.map_int_string___getitem__(self, key)

    def __delitem__(self, key: "std::map< int,std::string >::key_type const &") -> "void":
        return _multiresolutionimageinterface.map_int_string___delitem__(self, key)

    def has_key(self, key: "std::map< int,std::string >::key_type const &") -> "bool":
        return _multiresolutionimageinterface.map_int_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_keys(self)

    def values(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_values(self)

    def items(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_items(self)

    def __contains__(self, key: "std::map< int,std::string >::key_type const &") -> "bool":
        return _multiresolutionimageinterface.map_int_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_int_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.map_int_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_int_string_asdict(self)

    def __init__(self, *args):
        _multiresolutionimageinterface.map_int_string_swiginit(self, _multiresolutionimageinterface.new_map_int_string(*args))

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.map_int_string_empty(self)

    def size(self) -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string_size(self)

    def swap(self, v: "map_int_string") -> "void":
        return _multiresolutionimageinterface.map_int_string_swap(self, v)

    def begin(self) -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_begin(self)

    def end(self) -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_end(self)

    def rbegin(self) -> "std::map< int,std::string >::reverse_iterator":
        return _multiresolutionimageinterface.map_int_string_rbegin(self)

    def rend(self) -> "std::map< int,std::string >::reverse_iterator":
        return _multiresolutionimageinterface.map_int_string_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.map_int_string_clear(self)

    def get_allocator(self) -> "std::map< int,std::string >::allocator_type":
        return _multiresolutionimageinterface.map_int_string_get_allocator(self)

    def count(self, x: "std::map< int,std::string >::key_type const &") -> "std::map< int,std::string >::size_type":
        return _multiresolutionimageinterface.map_int_string_count(self, x)

    def erase(self, *args) -> "void":
        return _multiresolutionimageinterface.map_int_string_erase(self, *args)

    def find(self, x: "std::map< int,std::string >::key_type const &") -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_find(self, x)

    def lower_bound(self, x: "std::map< int,std::string >::key_type const &") -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_lower_bound(self, x)

    def upper_bound(self, x: "std::map< int,std::string >::key_type const &") -> "std::map< int,std::string >::iterator":
        return _multiresolutionimageinterface.map_int_string_upper_bound(self, x)
    __swig_destroy__ = _multiresolutionimageinterface.delete_map_int_string

# Register map_int_string in _multiresolutionimageinterface:
_multiresolutionimageinterface.map_int_string_swigregister(map_int_string)

class map_string_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int___bool__(self)

    def __len__(self) -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::mapped_type const &":
        return _multiresolutionimageinterface.map_string_int___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,int >::key_type const &") -> "void":
        return _multiresolutionimageinterface.map_string_int___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,int >::key_type const &") -> "bool":
        return _multiresolutionimageinterface.map_string_int_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_keys(self)

    def values(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_values(self)

    def items(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_items(self)

    def __contains__(self, key: "std::map< std::string,int >::key_type const &") -> "bool":
        return _multiresolutionimageinterface.map_string_int___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _multiresolutionimageinterface.map_string_int_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _multiresolutionimageinterface.map_string_int___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _multiresolutionimageinterface.map_string_int_asdict(self)

    def __init__(self, *args):
        _multiresolutionimageinterface.map_string_int_swiginit(self, _multiresolutionimageinterface.new_map_string_int(*args))

    def empty(self) -> "bool":
        return _multiresolutionimageinterface.map_string_int_empty(self)

    def size(self) -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int_size(self)

    def swap(self, v: "map_string_int") -> "void":
        return _multiresolutionimageinterface.map_string_int_swap(self, v)

    def begin(self) -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_begin(self)

    def end(self) -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_end(self)

    def rbegin(self) -> "std::map< std::string,int >::reverse_iterator":
        return _multiresolutionimageinterface.map_string_int_rbegin(self)

    def rend(self) -> "std::map< std::string,int >::reverse_iterator":
        return _multiresolutionimageinterface.map_string_int_rend(self)

    def clear(self) -> "void":
        return _multiresolutionimageinterface.map_string_int_clear(self)

    def get_allocator(self) -> "std::map< std::string,int >::allocator_type":
        return _multiresolutionimageinterface.map_string_int_get_allocator(self)

    def count(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::size_type":
        return _multiresolutionimageinterface.map_string_int_count(self, x)

    def erase(self, *args) -> "void":
        return _multiresolutionimageinterface.map_string_int_erase(self, *args)

    def find(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_find(self, x)

    def lower_bound(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,int >::key_type const &") -> "std::map< std::string,int >::iterator":
        return _multiresolutionimageinterface.map_string_int_upper_bound(self, x)
    __swig_destroy__ = _multiresolutionimageinterface.delete_map_string_int

# Register map_string_int in _multiresolutionimageinterface:
_multiresolutionimageinterface.map_string_int_swigregister(map_string_int)

ASAP_MAJOR_VERSION = _multiresolutionimageinterface.ASAP_MAJOR_VERSION
ASAP_MINOR_VERSION = _multiresolutionimageinterface.ASAP_MINOR_VERSION
ASAP_PATCH_VERSION = _multiresolutionimageinterface.ASAP_PATCH_VERSION
class Point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _multiresolutionimageinterface.Point_swiginit(self, _multiresolutionimageinterface.new_Point(*args))

    def getX(self) -> "float":
        return _multiresolutionimageinterface.Point_getX(self)

    def getY(self) -> "float":
        return _multiresolutionimageinterface.Point_getY(self)

    def setX(self, x: "float const &") -> "void":
        return _multiresolutionimageinterface.Point_setX(self, x)

    def setY(self, y: "float const &") -> "void":
        return _multiresolutionimageinterface.Point_setY(self, y)
    __swig_destroy__ = _multiresolutionimageinterface.delete_Point

# Register Point in _multiresolutionimageinterface:
_multiresolutionimageinterface.Point_swigregister(Point)
cvar = _multiresolutionimageinterface.cvar
ASAP_VERSION_STRING = cvar.ASAP_VERSION_STRING

class LUT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    indices = property(_multiresolutionimageinterface.LUT_indices_get, _multiresolutionimageinterface.LUT_indices_set)
    colors = property(_multiresolutionimageinterface.LUT_colors_get, _multiresolutionimageinterface.LUT_colors_set)
    relative = property(_multiresolutionimageinterface.LUT_relative_get, _multiresolutionimageinterface.LUT_relative_set)

    def __init__(self):
        _multiresolutionimageinterface.LUT_swiginit(self, _multiresolutionimageinterface.new_LUT())
    __swig_destroy__ = _multiresolutionimageinterface.delete_LUT

# Register LUT in _multiresolutionimageinterface:
_multiresolutionimageinterface.LUT_swigregister(LUT)

ColorType_InvalidColorType = _multiresolutionimageinterface.ColorType_InvalidColorType
ColorType_Monochrome = _multiresolutionimageinterface.ColorType_Monochrome
ColorType_RGB = _multiresolutionimageinterface.ColorType_RGB
ColorType_RGBA = _multiresolutionimageinterface.ColorType_RGBA
ColorType_Indexed = _multiresolutionimageinterface.ColorType_Indexed
DataType_InvalidDataType = _multiresolutionimageinterface.DataType_InvalidDataType
DataType_UChar = _multiresolutionimageinterface.DataType_UChar
DataType_UInt16 = _multiresolutionimageinterface.DataType_UInt16
DataType_UInt32 = _multiresolutionimageinterface.DataType_UInt32
DataType_Float = _multiresolutionimageinterface.DataType_Float
Compression_RAW = _multiresolutionimageinterface.Compression_RAW
Compression_JPEG = _multiresolutionimageinterface.Compression_JPEG
Compression_LZW = _multiresolutionimageinterface.Compression_LZW
Compression_JPEG2000 = _multiresolutionimageinterface.Compression_JPEG2000
Interpolation_NearestNeighbor = _multiresolutionimageinterface.Interpolation_NearestNeighbor
Interpolation_Linear = _multiresolutionimageinterface.Interpolation_Linear
class ImageSource(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_ImageSource

    def valid(self) -> "bool":
        return _multiresolutionimageinterface.ImageSource_valid(self)

    def getDimensions(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.ImageSource_getDimensions(self)

    def getColorType(self) -> "pathology::ColorType const":
        return _multiresolutionimageinterface.ImageSource_getColorType(self)

    def getDataType(self) -> "pathology::DataType const":
        return _multiresolutionimageinterface.ImageSource_getDataType(self)

    def getSamplesPerPixel(self) -> "int const":
        return _multiresolutionimageinterface.ImageSource_getSamplesPerPixel(self)

    def getSpacing(self) -> "std::vector< double,std::allocator< double > > const":
        return _multiresolutionimageinterface.ImageSource_getSpacing(self)

    def getMinValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.ImageSource_getMinValue(self, channel)

    def getMaxValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.ImageSource_getMaxValue(self, channel)

    def clone(self) -> "ImageSource *":
        return _multiresolutionimageinterface.ImageSource_clone(self)

# Register ImageSource in _multiresolutionimageinterface:
_multiresolutionimageinterface.ImageSource_swigregister(ImageSource)

class ProgressMonitor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.ProgressMonitor_swiginit(self, _multiresolutionimageinterface.new_ProgressMonitor())
    __swig_destroy__ = _multiresolutionimageinterface.delete_ProgressMonitor

    def setProgress(self, progress: "unsigned int const &") -> "void":
        return _multiresolutionimageinterface.ProgressMonitor_setProgress(self, progress)

    def setStatus(self, status: "std::string const &") -> "void":
        return _multiresolutionimageinterface.ProgressMonitor_setStatus(self, status)

    def status(self) -> "std::string":
        return _multiresolutionimageinterface.ProgressMonitor_status(self)

    def progress(self) -> "unsigned int":
        return _multiresolutionimageinterface.ProgressMonitor_progress(self)

    def __iadd__(self, increment: "unsigned int") -> "unsigned int":
        return _multiresolutionimageinterface.ProgressMonitor___iadd__(self, increment)

    def setMaximumProgress(self, maxProgress: "unsigned int const &") -> "void":
        return _multiresolutionimageinterface.ProgressMonitor_setMaximumProgress(self, maxProgress)

    def maximumProgress(self) -> "unsigned int":
        return _multiresolutionimageinterface.ProgressMonitor_maximumProgress(self)

# Register ProgressMonitor in _multiresolutionimageinterface:
_multiresolutionimageinterface.ProgressMonitor_swigregister(ProgressMonitor)

class CmdLineProgressMonitor(ProgressMonitor):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.CmdLineProgressMonitor_swiginit(self, _multiresolutionimageinterface.new_CmdLineProgressMonitor())
    __swig_destroy__ = _multiresolutionimageinterface.delete_CmdLineProgressMonitor

    def setProgress(self, progress: "unsigned int const &") -> "void":
        return _multiresolutionimageinterface.CmdLineProgressMonitor_setProgress(self, progress)

    def setStatus(self, status: "std::string const &") -> "void":
        return _multiresolutionimageinterface.CmdLineProgressMonitor_setStatus(self, status)

# Register CmdLineProgressMonitor in _multiresolutionimageinterface:
_multiresolutionimageinterface.CmdLineProgressMonitor_swigregister(CmdLineProgressMonitor)

class AnnotationBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationBase

    def setName(self, name: "std::string const &") -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setName(self, name)

    def getName(self) -> "std::string":
        return _multiresolutionimageinterface.AnnotationBase_getName(self)

    def setGroup(self, group: "std::shared_ptr< AnnotationGroup > const &") -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setGroup(self, group)

    def getGroup(self) -> "std::shared_ptr< AnnotationGroup >":
        return _multiresolutionimageinterface.AnnotationBase_getGroup(self)

    def getColor(self) -> "std::string":
        return _multiresolutionimageinterface.AnnotationBase_getColor(self)

    def setColor(self, color: "std::string const &") -> "void":
        return _multiresolutionimageinterface.AnnotationBase_setColor(self, color)

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationBase_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationBase_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.AnnotationBase_getCenter(self)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.AnnotationBase_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.AnnotationBase_getNumberOfPoints(self)

    def isModified(self) -> "bool":
        return _multiresolutionimageinterface.AnnotationBase_isModified(self)

    def resetModifiedStatus(self) -> "void":
        return _multiresolutionimageinterface.AnnotationBase_resetModifiedStatus(self)

# Register AnnotationBase in _multiresolutionimageinterface:
_multiresolutionimageinterface.AnnotationBase_swigregister(AnnotationBase)

class Annotation(AnnotationBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type_NONE = _multiresolutionimageinterface.Annotation_Type_NONE
    Type_DOT = _multiresolutionimageinterface.Annotation_Type_DOT
    Type_POLYGON = _multiresolutionimageinterface.Annotation_Type_POLYGON
    Type_SPLINE = _multiresolutionimageinterface.Annotation_Type_SPLINE
    Type_POINTSET = _multiresolutionimageinterface.Annotation_Type_POINTSET
    Type_MEASUREMENT = _multiresolutionimageinterface.Annotation_Type_MEASUREMENT
    Type_RECTANGLE = _multiresolutionimageinterface.Annotation_Type_RECTANGLE

    def __init__(self):
        _multiresolutionimageinterface.Annotation_swiginit(self, _multiresolutionimageinterface.new_Annotation())

    def addCoordinate(self, *args) -> "void":
        return _multiresolutionimageinterface.Annotation_addCoordinate(self, *args)

    def insertCoordinate(self, *args) -> "void":
        return _multiresolutionimageinterface.Annotation_insertCoordinate(self, *args)

    def removeCoordinate(self, index: "int const &") -> "void":
        return _multiresolutionimageinterface.Annotation_removeCoordinate(self, index)

    def setCoordinates(self, coordinates: "vector_point") -> "void":
        return _multiresolutionimageinterface.Annotation_setCoordinates(self, coordinates)

    def getCoordinate(self, index: "int const &") -> "Point":
        return _multiresolutionimageinterface.Annotation_getCoordinate(self, index)

    def getCoordinates(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getCoordinates(self)

    def clearCoordinates(self) -> "void":
        return _multiresolutionimageinterface.Annotation_clearCoordinates(self)

    def setType(self, type: "Annotation::Type const &") -> "void":
        return _multiresolutionimageinterface.Annotation_setType(self, type)

    def getType(self) -> "Annotation::Type":
        return _multiresolutionimageinterface.Annotation_getType(self)

    def getTypeAsString(self) -> "std::string":
        return _multiresolutionimageinterface.Annotation_getTypeAsString(self)

    def setTypeFromString(self, type: "std::string const &") -> "void":
        return _multiresolutionimageinterface.Annotation_setTypeFromString(self, type)

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.Annotation_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.Annotation_getCenter(self)

    def simplify(self, nrPoints: "unsigned int"=0, epsilon: "float"=1.0) -> "void":
        return _multiresolutionimageinterface.Annotation_simplify(self, nrPoints, epsilon)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.Annotation_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.Annotation_getNumberOfPoints(self)

    def isClockwise(self) -> "bool":
        return _multiresolutionimageinterface.Annotation_isClockwise(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_Annotation

# Register Annotation in _multiresolutionimageinterface:
_multiresolutionimageinterface.Annotation_swigregister(Annotation)

class AnnotationGroup(AnnotationBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.AnnotationGroup_swiginit(self, _multiresolutionimageinterface.new_AnnotationGroup())
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationGroup

    def getImageBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationGroup_getImageBoundingBox(self)

    def getLocalBoundingBox(self) -> "std::vector< Point,std::allocator< Point > >":
        return _multiresolutionimageinterface.AnnotationGroup_getLocalBoundingBox(self)

    def getCenter(self) -> "Point":
        return _multiresolutionimageinterface.AnnotationGroup_getCenter(self)

    def getArea(self) -> "float":
        return _multiresolutionimageinterface.AnnotationGroup_getArea(self)

    def getNumberOfPoints(self) -> "unsigned int":
        return _multiresolutionimageinterface.AnnotationGroup_getNumberOfPoints(self)

    def clearAttributes(self) -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_clearAttributes(self)

    def getAttributes(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        return _multiresolutionimageinterface.AnnotationGroup_getAttributes(self)

    def setAttributes(self, attributes: "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >") -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_setAttributes(self, attributes)

    def addMember(self, member: "std::shared_ptr< AnnotationBase >") -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_addMember(self, member)

    def removeMember(self, member: "std::shared_ptr< AnnotationBase >") -> "void":
        return _multiresolutionimageinterface.AnnotationGroup_removeMember(self, member)

# Register AnnotationGroup in _multiresolutionimageinterface:
_multiresolutionimageinterface.AnnotationGroup_swigregister(AnnotationGroup)

class AnnotationList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.AnnotationList_swiginit(self, _multiresolutionimageinterface.new_AnnotationList())
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationList

    def isModified(self) -> "bool":
        return _multiresolutionimageinterface.AnnotationList_isModified(self)

    def resetModifiedStatus(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_resetModifiedStatus(self)

    def addGroup(self, group: "std::shared_ptr< AnnotationGroup > const &") -> "bool":
        return _multiresolutionimageinterface.AnnotationList_addGroup(self, group)

    def addAnnotation(self, annotation: "std::shared_ptr< Annotation > const &") -> "bool":
        return _multiresolutionimageinterface.AnnotationList_addAnnotation(self, annotation)

    def getGroup(self, *args) -> "std::shared_ptr< AnnotationGroup >":
        return _multiresolutionimageinterface.AnnotationList_getGroup(self, *args)

    def getAnnotation(self, *args) -> "std::shared_ptr< Annotation >":
        return _multiresolutionimageinterface.AnnotationList_getAnnotation(self, *args)

    def getAnnotations(self) -> "std::vector< std::shared_ptr< Annotation >,std::allocator< std::shared_ptr< Annotation > > >":
        return _multiresolutionimageinterface.AnnotationList_getAnnotations(self)

    def getGroups(self) -> "std::vector< std::shared_ptr< AnnotationGroup >,std::allocator< std::shared_ptr< AnnotationGroup > > >":
        return _multiresolutionimageinterface.AnnotationList_getGroups(self)

    def setAnnotations(self, annotations: "vector_annotation") -> "void":
        return _multiresolutionimageinterface.AnnotationList_setAnnotations(self, annotations)

    def setGroups(self, groups: "vector_annotation_group") -> "void":
        return _multiresolutionimageinterface.AnnotationList_setGroups(self, groups)

    def removeGroup(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeGroup(self, *args)

    def removeAnnotation(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAnnotation(self, *args)

    def removeAllAnnotations(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAllAnnotations(self)

    def removeAllGroups(self) -> "void":
        return _multiresolutionimageinterface.AnnotationList_removeAllGroups(self)

# Register AnnotationList in _multiresolutionimageinterface:
_multiresolutionimageinterface.AnnotationList_swigregister(AnnotationList)

class AnnotationService(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.AnnotationService_swiginit(self, _multiresolutionimageinterface.new_AnnotationService())
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationService

    def getList(self) -> "std::shared_ptr< AnnotationList >":
        return _multiresolutionimageinterface.AnnotationService_getList(self)

    def getRepository(self) -> "std::shared_ptr< Repository >":
        return _multiresolutionimageinterface.AnnotationService_getRepository(self)

    def loadRepositoryFromFile(self, source: "std::string const &") -> "bool":
        return _multiresolutionimageinterface.AnnotationService_loadRepositoryFromFile(self, source)

    def saveRepositoryToFile(self, source: "std::string const &") -> "bool":
        return _multiresolutionimageinterface.AnnotationService_saveRepositoryToFile(self, source)

# Register AnnotationService in _multiresolutionimageinterface:
_multiresolutionimageinterface.AnnotationService_swigregister(AnnotationService)

class AnnotationToMask(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def convert(self, *args) -> "void":
        return _multiresolutionimageinterface.AnnotationToMask_convert(self, *args)

    def setProgressMonitor(self, monitor: "ProgressMonitor") -> "void":
        return _multiresolutionimageinterface.AnnotationToMask_setProgressMonitor(self, monitor)

    def __init__(self):
        _multiresolutionimageinterface.AnnotationToMask_swiginit(self, _multiresolutionimageinterface.new_AnnotationToMask())
    __swig_destroy__ = _multiresolutionimageinterface.delete_AnnotationToMask

# Register AnnotationToMask in _multiresolutionimageinterface:
_multiresolutionimageinterface.AnnotationToMask_swigregister(AnnotationToMask)

class Repository(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_Repository

    def setSource(self, sourcePath: "std::string const &") -> "void":
        return _multiresolutionimageinterface.Repository_setSource(self, sourcePath)

    def load(self) -> "bool":
        return _multiresolutionimageinterface.Repository_load(self)

    def save(self) -> "bool":
        return _multiresolutionimageinterface.Repository_save(self)

# Register Repository in _multiresolutionimageinterface:
_multiresolutionimageinterface.Repository_swigregister(Repository)

class XmlRepository(Repository):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, list: "std::shared_ptr< AnnotationList > const &"):
        _multiresolutionimageinterface.XmlRepository_swiginit(self, _multiresolutionimageinterface.new_XmlRepository(list))

    def save(self) -> "bool":
        return _multiresolutionimageinterface.XmlRepository_save(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_XmlRepository

# Register XmlRepository in _multiresolutionimageinterface:
_multiresolutionimageinterface.XmlRepository_swigregister(XmlRepository)

class NDPARepository(Repository):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, list: "std::shared_ptr< AnnotationList > const &"):
        _multiresolutionimageinterface.NDPARepository_swiginit(self, _multiresolutionimageinterface.new_NDPARepository(list))

    def setNDPISourceFile(self, ndpiSourcefile: "std::string const &") -> "void":
        return _multiresolutionimageinterface.NDPARepository_setNDPISourceFile(self, ndpiSourcefile)

    def NDPISourceFile(self) -> "std::string":
        return _multiresolutionimageinterface.NDPARepository_NDPISourceFile(self)

    def save(self) -> "bool":
        return _multiresolutionimageinterface.NDPARepository_save(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_NDPARepository

# Register NDPARepository in _multiresolutionimageinterface:
_multiresolutionimageinterface.NDPARepository_swigregister(NDPARepository)

class ImageScopeRepository(Repository):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, list: "std::shared_ptr< AnnotationList > const &"):
        _multiresolutionimageinterface.ImageScopeRepository_swiginit(self, _multiresolutionimageinterface.new_ImageScopeRepository(list))

    def save(self) -> "bool":
        return _multiresolutionimageinterface.ImageScopeRepository_save(self)

    def setClosingDistance(self, closingDistance: "float const &") -> "void":
        return _multiresolutionimageinterface.ImageScopeRepository_setClosingDistance(self, closingDistance)

    def getClosingDistance(self) -> "float":
        return _multiresolutionimageinterface.ImageScopeRepository_getClosingDistance(self)
    __swig_destroy__ = _multiresolutionimageinterface.delete_ImageScopeRepository

# Register ImageScopeRepository in _multiresolutionimageinterface:
_multiresolutionimageinterface.ImageScopeRepository_swigregister(ImageScopeRepository)

class MultiResolutionImage(ImageSource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImage

    def clone(self) -> "ImageSource *":
        return _multiresolutionimageinterface.MultiResolutionImage_clone(self)

    def initialize(self, imagePath: "std::string const &") -> "bool":
        return _multiresolutionimageinterface.MultiResolutionImage_initialize(self, imagePath)

    def initializeType(self, imagePath: "std::string const &") -> "bool":
        return _multiresolutionimageinterface.MultiResolutionImage_initializeType(self, imagePath)

    def getNumberOfZPlanes(self) -> "int":
        return _multiresolutionimageinterface.MultiResolutionImage_getNumberOfZPlanes(self)

    def setCurrentZPlaneIndex(self, zPlaneIndex: "unsigned int const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImage_setCurrentZPlaneIndex(self, zPlaneIndex)

    def getCurrentZPlaneIndex(self) -> "unsigned int":
        return _multiresolutionimageinterface.MultiResolutionImage_getCurrentZPlaneIndex(self)

    def getProperty(self, propertyName: "std::string const &") -> "std::string":
        return _multiresolutionimageinterface.MultiResolutionImage_getProperty(self, propertyName)

    def getCacheSize(self) -> "unsigned long long const":
        return _multiresolutionimageinterface.MultiResolutionImage_getCacheSize(self)

    def setCacheSize(self, cacheSize: "unsigned long long const") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImage_setCacheSize(self, cacheSize)

    def getNumberOfLevels(self) -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImage_getNumberOfLevels(self)

    def getDimensions(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.MultiResolutionImage_getDimensions(self)

    def getLevelDimensions(self, level: "unsigned int const &") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > const":
        return _multiresolutionimageinterface.MultiResolutionImage_getLevelDimensions(self, level)

    def getLevelDownsample(self, level: "unsigned int const &") -> "double const":
        return _multiresolutionimageinterface.MultiResolutionImage_getLevelDownsample(self, level)

    def getBestLevelForDownSample(self, downsample: "double const &") -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImage_getBestLevelForDownSample(self, downsample)

    def getMinValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.MultiResolutionImage_getMinValue(self, channel)

    def getMaxValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.MultiResolutionImage_getMaxValue(self, channel)

    def getFileType(self) -> "std::string const":
        return _multiresolutionimageinterface.MultiResolutionImage_getFileType(self)

    def getUCharPatch(self, startX: "long long const &", startY: "long long const &", width: "unsigned long long const &", height: "unsigned long long const &", level: "unsigned int const &") -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUCharPatch(self, startX, startY, width, height, level)

    def getUInt16Patch(self, startX: "long long const &", startY: "long long const &", width: "unsigned long long const &", height: "unsigned long long const &", level: "unsigned int const &") -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUInt16Patch(self, startX, startY, width, height, level)

    def getUInt32Patch(self, startX: "long long const &", startY: "long long const &", width: "unsigned long long const &", height: "unsigned long long const &", level: "unsigned int const &") -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getUInt32Patch(self, startX, startY, width, height, level)

    def getFloatPatch(self, startX: "long long const &", startY: "long long const &", width: "unsigned long long const &", height: "unsigned long long const &", level: "unsigned int const &") -> "PyObject *":
        return _multiresolutionimageinterface.MultiResolutionImage_getFloatPatch(self, startX, startY, width, height, level)

# Register MultiResolutionImage in _multiresolutionimageinterface:
_multiresolutionimageinterface.MultiResolutionImage_swigregister(MultiResolutionImage)

class TIFFImage(MultiResolutionImage):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.TIFFImage_swiginit(self, _multiresolutionimageinterface.new_TIFFImage())
    __swig_destroy__ = _multiresolutionimageinterface.delete_TIFFImage

    def initializeType(self, imagePath: "std::string const &") -> "bool":
        return _multiresolutionimageinterface.TIFFImage_initializeType(self, imagePath)

    def getMinValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.TIFFImage_getMinValue(self, channel)

    def getMaxValue(self, channel: "int"=-1) -> "double":
        return _multiresolutionimageinterface.TIFFImage_getMaxValue(self, channel)

    def getEncodedTileSize(self, startX: "long long const &", startY: "long long const &", level: "unsigned int const &") -> "long long":
        return _multiresolutionimageinterface.TIFFImage_getEncodedTileSize(self, startX, startY, level)

    def readEncodedDataFromImage(self, startX: "long long const &", startY: "long long const &", level: "unsigned int const &") -> "unsigned char *":
        return _multiresolutionimageinterface.TIFFImage_readEncodedDataFromImage(self, startX, startY, level)

    def getEncodedTile(self, startX: "long long const &", startY: "long long const &", level: "unsigned int const &") -> "PyObject *":
        return _multiresolutionimageinterface.TIFFImage_getEncodedTile(self, startX, startY, level)

# Register TIFFImage in _multiresolutionimageinterface:
_multiresolutionimageinterface.TIFFImage_swigregister(TIFFImage)


def MultiResolutionImageToTIFFImage(base: "std::shared_ptr< MultiResolutionImage >") -> "std::shared_ptr< TIFFImage >":
    return _multiresolutionimageinterface.MultiResolutionImageToTIFFImage(base)
class MultiResolutionImageReader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.MultiResolutionImageReader_swiginit(self, _multiresolutionimageinterface.new_MultiResolutionImageReader())
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImageReader

    def open(self, *args) -> "MultiResolutionImage *":
        return _multiresolutionimageinterface.MultiResolutionImageReader_open(self, *args)

# Register MultiResolutionImageReader in _multiresolutionimageinterface:
_multiresolutionimageinterface.MultiResolutionImageReader_swigregister(MultiResolutionImageReader)

class MultiResolutionImageWriter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _multiresolutionimageinterface.MultiResolutionImageWriter_swiginit(self, _multiresolutionimageinterface.new_MultiResolutionImageWriter())
    __swig_destroy__ = _multiresolutionimageinterface.delete_MultiResolutionImageWriter

    def openFile(self, fileName: "std::string const &") -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_openFile(self, fileName)

    def getOpenFile(self) -> "std::string const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getOpenFile(self)

    def writeImageInformation(self, sizeX: "unsigned long long const &", sizeY: "unsigned long long const &") -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeImageInformation(self, sizeX, sizeY)

    def writeBaseImagePart(self, data: "void *") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeBaseImagePart(self, data)

    def writeBaseImagePartToLocation(self, data: "void *", x: "unsigned long long const &", y: "unsigned long long const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeBaseImagePartToLocation(self, data, x, y)

    def writeImageToFile(self, img: "MultiResolutionImage", fileName: "std::string const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_writeImageToFile(self, img, fileName)

    def finishImage(self) -> "int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_finishImage(self)

    def setCompression(self, codec: "pathology::Compression const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setCompression(self, codec)

    def getCompression(self) -> "pathology::Compression const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getCompression(self)

    def setInterpolation(self, interpolation: "pathology::Interpolation const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setInterpolation(self, interpolation)

    def getInterpolation(self) -> "pathology::Interpolation const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getInterpolation(self)

    def getMaxNumberOfPyramidLevels(self) -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getMaxNumberOfPyramidLevels(self)

    def setMaxNumberOfPyramidLevels(self, maxNrPyramidLevels: "int const") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setMaxNumberOfPyramidLevels(self, maxNrPyramidLevels)

    def getDownsamplePerLevel(self) -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getDownsamplePerLevel(self)

    def setDownsamplePerLevel(self, downsamplePerLevel: "int const") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setDownsamplePerLevel(self, downsamplePerLevel)

    def setDataType(self, dType: "pathology::DataType const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setDataType(self, dType)

    def getDataType(self) -> "pathology::DataType const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getDataType(self)

    def setColorType(self, cType: "pathology::ColorType const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setColorType(self, cType)

    def setNumberOfIndexedColors(self, numberOfIndexedColors: "unsigned int const") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setNumberOfIndexedColors(self, numberOfIndexedColors)

    def getNumberOfIndexedColors(self) -> "unsigned int":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getNumberOfIndexedColors(self)

    def getColorType(self) -> "pathology::ColorType const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getColorType(self)

    def setTileSize(self, tileSize: "unsigned int const &") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setTileSize(self, tileSize)

    def setSpacing(self, spacing: "vector_double") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setSpacing(self, spacing)

    def getTileSize(self) -> "unsigned int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getTileSize(self)

    def getOverrideSpacing(self) -> "std::vector< double,std::allocator< double > > const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getOverrideSpacing(self)

    def setOverrideSpacing(self, spacing: "vector_double") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setOverrideSpacing(self, spacing)

    def setJPEGQuality(self, quality: "float const &") -> "int const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setJPEGQuality(self, quality)

    def getJPEGQuality(self) -> "float const":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_getJPEGQuality(self)

    def setProgressMonitor(self, monitor: "ProgressMonitor") -> "void":
        return _multiresolutionimageinterface.MultiResolutionImageWriter_setProgressMonitor(self, monitor)

# Register MultiResolutionImageWriter in _multiresolutionimageinterface:
_multiresolutionimageinterface.MultiResolutionImageWriter_swigregister(MultiResolutionImageWriter)



